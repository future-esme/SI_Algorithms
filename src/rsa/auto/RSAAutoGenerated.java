package rsa.auto;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class RSAAutoGenerated {
    private static final String RESET = "\u001B[0m";
    private static final String RED = "\u001B[31m";
    private static final String BLUE = "\u001B[34m";

    private static final BigInteger ONE = BigInteger.ONE;
    private static final BigInteger ZERO = BigInteger.ZERO;

    private static BigInteger encrypt(PublicKey publicKey, int toEncrypt) {
        var key = publicKey.exponent();
        var n = publicKey.modulus();
        return BigInteger.valueOf(toEncrypt).modPow(key, n);
    }

    private static int decrypt(PrivateKey privateKey, BigInteger toDecrypt) {
        var key = privateKey.exponent();
        var n = privateKey.modulus();
        BigInteger result = toDecrypt.modPow(key, n);
        return result.intValue();
    }

    private static List<BigInteger> getEncryptedMessage(String message, KeyPair keyPair) {
        List<BigInteger> encryptedMessage = new ArrayList<>();
        for (var i = 0; i < message.length(); i++) {
            encryptedMessage.add(encrypt(keyPair.publicKey(), message.charAt(i)));
        }
        return encryptedMessage;
    }

    private static String getDecryptedMessage(List<BigInteger> encryptedMessage, KeyPair keyPair) {
        var decryptedMessage = new StringBuilder();
        for (var integer : encryptedMessage) {
            decryptedMessage.append((char) decrypt(keyPair.privateKey(), integer));
        }
        return decryptedMessage.toString();
    }

    private static BigInteger findE(BigInteger phi) {
        var e = 2;

        while (BigInteger.valueOf(e).compareTo(phi) < 0) {
            if (BigInteger.valueOf(e).gcd(phi).equals(ONE))
                break;
            else
                e++;
        }
        return BigInteger.valueOf(e);
    }

    public static BigInteger findD(BigInteger e, BigInteger phi) {
        /*e = e.mod(phi);
        for (var x = ONE; x.compareTo(phi) < 0; x = x.add(ONE)) {
            if (e.multiply(x).mod(phi).equals(ONE)) {
                return x;
            }
        }
        return ONE;*/

        for (var i = ZERO; i.compareTo(BigInteger.valueOf(9)) < 0; i = i.add(ONE)) {
            var x = ONE.add(i.multiply(phi));
            if (x.mod(e).equals(ZERO)) {
                return x.divide(e);
            }
        }
        return ONE;
    }

    private static void printInfo(String... varargs) {
        var message = new StringBuilder(BLUE);
        for (var arg : varargs) {
            message.append(arg);
        }
        message.append(RESET);
        System.out.println(message);
    }

    private static void printError(String... varargs) {
        var message = new StringBuilder(RED);
        for (var arg : varargs) {
            message.append(arg);
        }
        message.append(RESET);
        System.out.println(message);
    }

    private static KeyPair generateKeyPair() {
        var p = BigInteger.probablePrime(1024, new Random());
        var q = BigInteger.probablePrime(1024, new Random());

        printInfo("Prime numbers:");
        printInfo("P = ", p.toString());
        printInfo("Q = ", q.toString());

        var n = p.multiply(q);
        var phi = p.subtract(ONE).multiply(q.subtract(ONE));

        var e = findE(phi);
        var d = findD(e, phi);

        var privateKey = new PrivateKey(d, n);
        var publicKey = new PublicKey(e, n);
        printInfo("Private key: ", privateKey.toString());
        printInfo("Public key: ", publicKey.toString());
        return new KeyPair(privateKey, publicKey);
    }

    private static String readLine() {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        try {
            return bufferedReader.readLine();
        } catch (Exception e) {
            printError("Entered text is not valid");
        }
        return "";
    }

    public static void main(String... args) {
        var keyPair = generateKeyPair();

        printInfo("Enter message: ");
        var message = readLine();
        List<BigInteger> encryptedMessage = getEncryptedMessage(message, keyPair);

        printInfo("Encrypted message: ", encryptedMessage.toString());

        var decryptedMessage = getDecryptedMessage(encryptedMessage, keyPair);

        printInfo("Decrypted message: ", decryptedMessage);
    }
}
